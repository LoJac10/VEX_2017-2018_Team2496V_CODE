#pragma config(Sensor, in1,    MogoL,          sensorPotentiometer)
#pragma config(Sensor, in2,    MogoR,          sensorPotentiometer)
#pragma config(Sensor, in3,    liftL,          sensorPotentiometer)
#pragma config(Sensor, in4,    inte,           sensorPotentiometer)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl4,  rightQua,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftQua,        sensorQuadEncoder)
#pragma config(Motor,  port1,           mogoLiftL,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FRMotor,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           liftMotorR,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           clawMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BRMotor,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           BLMotor,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           integrator,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           liftMotorL ,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FLMotor,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mogoLiftR,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************2017-2018**********\
*	2496V ITZ Autostack Program  *
*	      RobotC Version         *
* Based off of original in PROS*
\*******************************/

/* Autostack Varibles */
int stackHeight = 0;		//Amount of cones currently stacked
int stage = 0;					//0-awaiting intake, 1-lift move, 2-4bar & stack deposit, 3-manual
int dCmd = time1[T1];		//Time which 6D was last pressed
bool r6U = false;				//Rising edge detection for buttons
bool r6D = false;
bool p6U = false;
bool p6D = false;
const int INTEG_BOT = 890; //4 bar top and bottom limits
const int INTEG_TOP = 3000;
const int INTEG_GO  = 300; //DR4B Height at which stage 2 should begin

/* PID Variables */
int desiredLift = 0; 	  //Requested value for dr4b
int actualHeight = 0;		//Actual value for dr4b
const float kP = 0.4;		//PID constants
const float kI = 0.0;
const float kD = 7.0;
int integ_count = 0;		//Integral data management
float integ_data = 0;
int integ_limit=0;
int prevTime = 0;				//Last iteration data
float prevError;

float PID(float error) {	//Standard PID with integ data cap. Please filter error appropriately
	float deltaT = time1[T1] - prevTime;
	prevTime = time1[T1];
	float pv = kP * error;
	float iv = kI * (integ_data+=error);
	float dv = kD * (error - prevError)/deltaT;
 	float PID = pv + iv + dv;
	prevError = error;
	integ_count++;
	if(integ_count >= integ_limit) {
		integ_data = 0;
		integ_count = 0;
	}
	return PID;
}

void iterateLiftCtl() {	//Lift autostack control
	actualHeight = 2520 - SensorValue[liftL];
	int speed = 0;
	if(stage == 0) {
		if(time1[T1] - dCmd >= 400) {
			desiredLift = 0;
			} else {
			desiredLift += 11;
		}
	}
	else if (stage == 1) {
		if(desiredLift - actualHeight <= INTEG_GO) stage = 2;
		desiredLift = ((stackHeight-1) * 100);
	} else if (stage == 3) {
	  motor[liftMotorL] = vexRT[Ch3Xmtr2];
		motor[liftMotorR] = vexRT[Ch3Xmtr2];
		return;
	}
	if(desiredLift<=0) desiredLift = 0;
	float error = (desiredLift-actualHeight);
	int rightMotor = PID(error);
	float leftMotor = rightMotor;
	if(stage == 0) {
		if(time1[T1] - dCmd >= 430) {
			if(leftMotor > -10) {
				leftMotor = -10;
				rightMotor = -10;
			}
		}
	}
	motor[liftMotorL] = leftMotor;
	motor[liftMotorR] = rightMotor;
}

void iterate4BCtl() {
	int speed = 0;
	if(stage < 2) {	//4 bar down position, hold 4b down
		if(SensorValue[inte] > INTEG_BOT) speed = -127;
		else if(SensorValue[inte] <= INTEG_BOT) speed = -14;

		} else if(stage == 2) {	//4 bar motion mode, move 4b up and hold
		if(SensorValue[inte] < INTEG_TOP) speed = 127;
		else if(SensorValue[inte] >= INTEG_TOP) {
			speed = 20;
			motor[clawMotor] = -40;
		}
		} else if (stage == 3){	//Manual mode, allow manual control
		if(vexRT[Btn5UXmtr2]) speed = 127;
		else if(vexRT[Btn5DXmtr2]) speed = -127;
		else speed = 0;
	}
	motor[integrator] = speed;
}

task main()
{
	while(1) {
		/* User Button Inputs */

		//Autostack a cone
		if(vexRT[Btn6U] && !r6U) {
			stackHeight++;
			stage = 1;
		}
		//Return to intake position
		else if(vexRT[Btn6D] && !r6D) {
			stage = 0;
			dCmd = time1[T1];
		}

		//Partner stack height override controls
		if(vexRT[Btn6UXmtr2] && !p6U) {
			stackHeight++;
			} else if(vexRT[Btn6DXmtr2] && !p6D) {
			stackHeight--;
		} else if(vexRT[Btn8RXmtr2]) stackHeight = 0;
		//Manual override mode detect
		if(abs(vexRT[Ch3Xmtr2]) >= 30 ||
			vexRT[Btn5UXmtr2] || vexRT[Btn5DXmtr2]) stage = 3;


		//Store for rising edge detect
		r6U = (bool)vexRT[Btn6U];
		r6D = (bool)vexRT[Btn6D];
		p6U = (bool)vexRT[Btn6UXmtr2];
		p6D = (bool)vexRT[Btn6DXmtr2];

		//Control lift and 4b based on autostack settings and user inputs
		iterateLiftCtl();
		iterate4BCtl();
		waitInMilliseconds(10);
		if(vexRT[Btn5U]) motor[clawMotor] = 127;
		else if(vexRT[Btn5D]) motor[clawMotor] = -127;
		else if(stage!=2) motor[clawMotor] = 20;
	}
}
